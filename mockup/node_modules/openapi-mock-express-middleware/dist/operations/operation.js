"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOperation = exports.Operation = void 0;
const lodash_1 = require("lodash");
const path_to_regexp_1 = require("path-to-regexp");
function isReferenceObject(response) {
    return typeof response === 'object' && response !== null && '$ref' in response;
}
class Operation {
    constructor({ method, path, operation, securitySchemes, generator, parentParams, }) {
        this.pathPattern = path.replace(/\{([^/}]+)\}/g, (p1, p2) => `:${p2}`);
        this.parentParams = parentParams || null;
        this.method = method.toUpperCase();
        this.operation = operation;
        this.path = path;
        this.securitySchemes = securitySchemes || null;
        this.generator = generator;
        const { regexp } = (0, path_to_regexp_1.pathToRegexp)(this.pathPattern);
        this.pathRegexp = regexp;
    }
    getResponseStatus() {
        const responses = (0, lodash_1.get)(this.operation, 'responses');
        if (!responses) {
            return 200;
        }
        const status = (0, lodash_1.findKey)(responses, (content, code) => {
            const statusCode = parseInt(code, 10);
            if (Number.isNaN(statusCode)) {
                return false;
            }
            return statusCode >= 200 && statusCode < 299;
        });
        return status ? parseInt(status, 10) : 200;
    }
    getResponseSchema(responseStatus = 200) {
        if ((0, lodash_1.has)(this.operation, ['responses', responseStatus, 'content', 'application/json', 'schema'])) {
            const { schema, example, examples } = (0, lodash_1.get)(this.operation, [
                'responses',
                responseStatus,
                'content',
                'application/json',
            ]);
            if (schema && !isReferenceObject(schema)) {
                const resultSchema = schema;
                if (example) {
                    resultSchema.example = example;
                }
                if (examples) {
                    resultSchema.examples = examples;
                }
                return resultSchema;
            }
            return null;
        }
        return null;
    }
    getSecurityRequirements() {
        const requirements = this.operation.security || [];
        return requirements;
    }
    getParamsSchemas() {
        const schemas = {
            header: {
                type: 'object',
                required: [],
            },
            query: {
                type: 'object',
                additionalProperties: false,
                required: [],
            },
            path: {
                type: 'object',
                additionalProperties: false,
                required: [],
            },
        };
        let parameters = [];
        if (this.parentParams) {
            parameters = [...this.parentParams];
        }
        const localParams = (0, lodash_1.get)(this.operation, ['parameters']);
        if (localParams) {
            parameters = [...parameters, ...localParams];
        }
        if (parameters) {
            parameters.forEach((parameter) => {
                if (parameter &&
                    !isReferenceObject(parameter) &&
                    (parameter.in === 'header' || parameter.in === 'query' || parameter.in === 'path') &&
                    schemas[parameter.in]) {
                    const prevRequired = schemas[parameter.in].required || [];
                    (0, lodash_1.set)(schemas, [
                        parameter.in,
                        'properties',
                        parameter.in === 'header' ? parameter.name.toLowerCase() : parameter.name,
                    ], parameter.schema);
                    if (parameter.required) {
                        (0, lodash_1.set)(schemas, [parameter.in, 'required'], [
                            ...prevRequired,
                            parameter.in === 'header' ? parameter.name.toLowerCase() : parameter.name,
                        ]);
                    }
                }
            });
        }
        return schemas;
    }
    getBodySchema(contentType) {
        return (0, lodash_1.get)(this.operation, ['requestBody', 'content', contentType, 'schema']);
    }
    generateResponse(req, res) {
        const responseStatus = this.getResponseStatus();
        const responseSchema = this.getResponseSchema(responseStatus);
        return res
            .status(responseStatus)
            .json(responseSchema ? this.generator.generate(responseSchema) : {});
    }
}
exports.Operation = Operation;
const createOperation = ({ method, path, operation, generator, securitySchemes, parentParams, }) => new Operation({
    method,
    path,
    operation,
    generator,
    securitySchemes,
    parentParams,
});
exports.createOperation = createOperation;
//# sourceMappingURL=operation.js.map