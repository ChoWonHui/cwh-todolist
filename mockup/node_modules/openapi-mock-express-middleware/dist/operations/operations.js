"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOperations = exports.Operations = void 0;
const path_1 = __importDefault(require("path"));
const chokidar_1 = __importDefault(require("chokidar"));
const swagger_parser_1 = __importDefault(require("@apidevtools/swagger-parser"));
const lodash_1 = require("lodash");
const utils_1 = require("../utils");
const operation_1 = require("./operation");
class Operations {
    constructor({ spec, options, callback, }) {
        this.operations = null;
        this.options = { sortPaths: false };
        if (options.sortPaths) {
            this.options.sortPaths = true;
        }
        this.spec = spec;
        this.watch();
        this.generator = (0, utils_1.createGenerator)(options, callback);
    }
    reset() {
        this.operations = null;
    }
    watch() {
        if (typeof this.spec !== 'string')
            return;
        const watcher = chokidar_1.default.watch(path_1.default.dirname(this.spec));
        watcher.on('all', () => this.reset());
    }
    compile() {
        return __awaiter(this, void 0, void 0, function* () {
            const api = yield swagger_parser_1.default.dereference(this.spec);
            const operations = this.options.sortPaths
                ? (0, lodash_1.toPairs)(api.paths).sort(utils_1.expressRouteComparator)
                : (0, lodash_1.toPairs)(api.paths);
            this.operations = operations.reduce((result, [pathName, pathOperations]) => [
                ...result,
                ...this.compileFromPath(pathName, pathOperations, (0, lodash_1.get)(api, 'components.securitySchemes')),
            ], []);
        });
    }
    /* eslint-disable class-methods-use-this */
    compileFromPath(pathName, pathOperations, securitySchemes) {
        const { parameters } = pathOperations, rest = __rest(pathOperations, ["parameters"]);
        return (0, lodash_1.toPairs)(rest).map(([method, operation]) => (0, operation_1.createOperation)({
            method,
            path: pathName,
            operation: operation,
            securitySchemes,
            generator: this.generator,
            parentParams: parameters,
        }));
    }
    /* eslint-enable class-methods-use-this */
    match(req) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.operations) {
                yield this.compile();
            }
            const { method, path: pathname } = req;
            return ((this.operations &&
                this.operations.find(({ method: operationMethod, pathRegexp }) => pathRegexp.exec(pathname) && method.toUpperCase() === operationMethod.toUpperCase())) ||
                null);
        });
    }
}
exports.Operations = Operations;
const createOperations = ({ spec, options, callback, }) => new Operations({ spec, options, callback });
exports.createOperations = createOperations;
//# sourceMappingURL=operations.js.map